<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<!-- 
    是什么？
        ES6提供了新的数据结构 Set 类似数组但成员都是唯一的没有重复值        
        属性
            Set.prototype.construct: 构造函数，默认就是Set函数
            Set.prototype.size : 返回Set实例的成员总数
        方法
            add(value)：添加某个值，返回 Set 结构本身。
            delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
            has(value)：返回一个布尔值，表示该值是否为Set的成员。
            clear()：清除所有成员，没有返回值。
            ****遍历*****  （Set的遍历顺序就是插入顺序）
            keys()：返回键名的遍历器
            values()：返回键值的遍历器
            entries()：返回键值对的遍历器
            forEach()：使用回调函数遍历每个成员

        Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键
            Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现
        属性
            size 属性返回 Map 结构的成员总数
        方法
            set(key, value) 设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键
            get(key)
            has(key) 返回一个布尔值
            delete(key) 返回一个布尔值
            clear()
            keys()：返回键名的遍历器。
            values()：返回键值的遍历器。
            entries()：返回所有成员的遍历器。
            forEach()：遍历 Map 的所有成员。

    怎么用？
        Set() 可以接受一个数组（或有iterable接口的其他数据结构)作为参数用来初始化。 
        向 Set 加入值的时候，不会发生类型转换  ,类似于精确相等运算符（===），主要的区别是NaN等于自身
        任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map



    WeakSet 
        结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。首先，WeakSet 的成员只能是对象，而不能是其他类型的值
        WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
        WeakMap的键名所指向的对象，不计入垃圾回收机制
    -->

<body>
    <script>
        // 例一
        const set = new Set([1, 2, 3, 4, 4]);
        [...set]
        // [1, 2, 3, 4]

        // 例二
        const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
        items.size // 5

        // 例三
        function divs() {
            return [...document.querySelectorAll('div')];
        }

        // 去除数组的重复成员
        console.dir([...new Set([12,23,4,4,12])]) 

        // Array.from 可以将set结构转为数组
        const items2 = new Set([1,3,4,5]);
        const array = Array.from(items2);

        // 数组去重 2
        function dedupe (array) {
            return Array.from(new Set(array));
        }
        console.dir(dedupe([1,2,3,3,3,3,4]))

        // Set 实现并集，交集，差集
        let a = new Set([1,2,3]);
        let b = new Set([4,3,2]);
       
        let union = new Set([...a,...b]); // 并集
        let intersect = new Set([...a].filter(x => b.has(x))); //交集
        let diff = new Set([...a].filter(x=>!b.has(x)));//差集
        console.dir(union);
        console.dir(intersect);
        console.dir(diff);


        // Map
        const set = new Set([
            ['foo', 1],
            ['bar', 2]
        ]);
        const m1 = new Map(set);
        m1.get('foo') // 1


        // 只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。
        const map = new Map();
        map.set(['a'], 555);
        map.get(['a']) // undefined 内存地址是不一样的，因此get方法无法读取该键，返回undefined
        



        // Map转换
        const myMap = new Map()
            .set(true, 7)
            .set({foo: 3}, ['abc']);
        [...myMap]  // [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ] Map 转为数组


       
    </script>
</body>

</html>